<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="./lib/three.js"></script>
    <script type="text/javascript" src="./lib/OrbitControls.js"></script>
    <script type="text/javascript" src="./lib/MTLLoader.js"></script>
    <script type="text/javascript" src="./lib/OBJLoader.js"></script>
    <script type="text/javascript" src="./lib/Stats.js"></script>
    <script type="text/javascript" src="./lib/tween.min.js"></script>
    <script type="text/javascript" src="./lib/DragControls.js"></script>
    <script type="text/javascript" src="./lib/TransformControls.js"></script>
    <script type="text/javascript" src="./lib/THREE.MeshLine.js"></script>
    <!-- <script type="text/javascript" src="./data.js"></script> -->
    <script type="text/javascript" src="./cons.js"></script>
    <link rel="stylesheet" href="./public/style.css">

    <script>
        var Topo = {
            canvasId: "mainCanvas",
            width: 1920,
            height: 1080,
            scene: null,
            camera: null,
            renderer: null,
            fov: 40,
            id: null,
            controls: null,
            stats: null,
            twwenF: null,
            Objlength: 0,
            currNode: null, //点击左边的当前节点
            currSelectnode: null,
            Selectnode: null,
            inputX: null,
            inputY: null,
            nexus: {
                links: [],
                nodes: []
            },
            onWindowResize() {
                //自适应
                Topo.camera.aspect = window.innerWidth / window.innerHeight;
                Topo.camera.updateProjectionMatrix();
                Topo.renderer.setSize(window.innerWidth, window.innerHeight);
            },
            initLight() {
                //光源
                let light = new THREE.DirectionalLight(0xffffff);
                light.position.set(30, 30, 70);
                Topo.scene.add(light);
                //环境光
                let ambient = new THREE.AmbientLight(0x404040); // soft white light
                Topo.scene.add(ambient);
            },
            initCamea() {
                //加载
                Topo.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('mainCanvas')
                });
                Topo.renderer.setClearColor(0x000f1c, 1.0);
                Topo.scene = new THREE.Scene();
                //相机
                Topo.camera = new THREE.PerspectiveCamera(Topo.fov, Topo.width / Topo.height, 1, 10000);
                Topo.camera.position.set(195, 200, 430);
                Topo.camera.lookAt(new THREE.Vector3(0, 0, 0));
                Topo.scene.add(Topo.camera);

            },
            renders() {
                //更新   
                Topo.stats.update()
                Topo.renderer.render(Topo.scene, Topo.camera);
                requestAnimationFrame(Topo.renders);
            },
            initControls() {
                //创建鼠标事件
                Topo.controls = new THREE.OrbitControls(Topo.camera, Topo.renderer.domElement);
                Topo.controls.enableDamping = true;
                //动态阻尼系数 就是鼠标拖拽旋转灵敏度
                Topo.controls.dampingFactor = 1;
                //是否可以缩放
                Topo.controls.enableZoom = true;
                //是否自动旋转 controls.autoRotate = true; 设置相机距离原点的最远距离
                Topo.controls.minDistance = 20;
                //设置相机距离原点的最远距离
                Topo.controls.maxDistance = 900;
                //是否开启右键拖拽
                Topo.controls.enablePan = true;
            },
            initStats() {
                //监控帧数
                Topo.stats = new Stats()
                Topo.stats.setMode(0)
                document.getElementById("stats").innerHTML = ""
                document.getElementById("stats").appendChild(Topo.stats.domElement)
            },
            initFooter() {
                //加载地板
                let foot = THREE.ImageUtils.loadTexture('./assets/foot.jpg', {}, () => {
                    Topo.renderer.render(Topo.scene, Topo.camera);
                });
                foot.wrapS = foot.wrapT = THREE.RepeatWrapping;
                foot.repeat.set(Topo.width / 40, Topo.height / 40);
                let plane = new THREE.Mesh(new THREE.PlaneGeometry(Topo.width, Topo.height),
                    new THREE.MeshLambertMaterial({
                        map: foot,
                        side: THREE.DoubleSide,
                    }));
                plane.rotation.x = -Math.PI / 2;
                Topo.scene.add(plane);
            },
            inigSign({
                x,
                y,
                z,
                name,
                id
            }) {
                //字体 
                let height = 15
                let materials = new THREE.MeshLambertMaterial({
                    color: 0xffcf43,
                    lightMapIntensity: 1
                });
                let loader = new THREE.FontLoader();
                //读取字体JSON文件 创建字体
                loader.load('./lib/helvetiker_regular.typeface.json', function (font) {
                    let textFont = new THREE.TextGeometry(name, {
                        font: font,
                        size: 6,
                        height: 1,
                    })
                    textFont.center()
                    let mesh1 = new THREE.Mesh(textFont, materials);
                    mesh1.position.x = x;
                    mesh1.position.y = y + height;
                    mesh1.position.z = z;
                    mesh1.params = {
                        id: id,
                        type: "font"
                    }
                    Topo.scene.add(mesh1);

                });

                //显示名字
                var geometry = new THREE.PlaneGeometry(65, 12, 0);
                var material = new THREE.MeshBasicMaterial({
                    color: 0x675121,
                    side: THREE.DoubleSide
                });
                var plane = new THREE.Mesh(geometry, material);
                plane.position.x = x;
                plane.position.y = y + height;
                plane.position.z = z;
                plane.params = {
                    id: id,
                    type: "font"
                }
                Topo.scene.add(plane);
            },
            addLink({
                x,
                y
            }) {
                //添加线条
                let geometry = new THREE.Geometry();
                let material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    linewidth: 2
                });
                let color1 = new THREE.Color(0x42aaff),
                    color2 = new THREE.Color(0x42aaff);
                // 线的材质可以由2点的颜色决定 线的材质可以由2点的颜色决定
                let p1 = new THREE.Vector3(x.x, x.y, x.z);
                let p2 = new THREE.Vector3(y.x, y.y, y.z);
                geometry.vertices.push(p1);
                geometry.vertices.push(p2);
                geometry.colors.push(color1, color2);
                let line = new THREE.Line(geometry, material);
                line.params = {
                    target: x.id,
                    source: y.id,
                    type: "link"
                }
                Topo.scene.add(line);
            },
            initObj(params) {
                //添加对象  
                let mtlLoader = new THREE.MTLLoader();
                mtlLoader.load(params.mtl, function (materials) {
                    materials.preload();
                    let objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.load(params.obj, function (object) {
                        object.position.y = params.y
                        object.position.x = params.x
                        object.position.z = params.z
                        object.params = {
                            id: params.id,
                            type: "node",
                            ip: params.ip,
                            dep: params.dep,
                            typeName: params.typeName,
                            type1: params.type,
                        }
                        Topo.scene.add(object)
                        Topo.Objlength++
                        if (Topo.Objlength === Topo.nexus.nodes.length) {
                            //加载完毕   
                            Topo.nexus.links.forEach(x => {
                                let target = Topo.nexus.nodes.filter(node => node.id == x.target)[
                                    0]
                                let source = Topo.nexus.nodes.filter(node => node.id == x.source)[
                                    0]
                                Topo.addLink({
                                    x: target,
                                    y: source,
                                })
                            })
                        }
                    });
                });

            },
            initData() {
                //数据 
                Topo.Objlength = 0;
                Topo.nexus.nodes.forEach((x, i) => {
                    if (x.type == 1) {
                        //主机
                        x = {
                            ...x,
                            ...models.host
                        }
                        Topo.initObj(x)
                    } else if (x.type == 2) {
                        //服务器
                        x = {
                            ...x,
                            ...models.server
                        }
                        Topo.initObj(x)
                    } else if (x.type == 3) {
                        //交换机
                        x = {
                            ...x,
                            ...models.switch
                        }
                        Topo.initObj(x)
                    } else if (x.type == 4) {
                        //路由器
                        x = {
                            ...x,
                            ...models.router
                        }
                        Topo.initObj(x)
                    } else if (x.type == 5) {
                        //路由器
                        x = {
                            ...x,
                            ...models.detection
                        }
                        Topo.initObj(x)
                    } else if (x.type == 6) {
                        //路由器
                        x = {
                            ...x,
                            ...models.firewall
                        }
                        Topo.initObj(x)
                    }

                    //需要title
                    if (x.name) {
                        Topo.inigSign(x)
                    }
                })
            },
            attackEvent({
                dst,
                src
            }) {
                //闪烁连线
                //找到src和dst节点
                let childns = Topo.scene.children.filter(x => x.params).filter(x => x.params.type == "node")
                let srcNode = childns.filter(x => src === x.params.ip)[0]
                let dstNode = childns.filter(x => dst === x.params.ip)[0]
                let arrSrc = []
                let arrTar = []
                Topo.getNodeTop(srcNode.params.id, arrSrc)
                Topo.getNodeTop(dstNode.params.id, arrTar)
                let arr = [...arrTar, ...arrSrc]
                var a1 = []
                arrSrc.forEach(x => {
                    arrTar.forEach(y => {
                        if (x.target == y.target && x.source == y.source) {
                            a1.push(y)
                        }
                    })
                })
                arr = arr.filter(x => {
                    return a1.filter(y => x.target == y.target && x.source == y.source).length == 0
                })
                Topo.activeLink(arr)
                return arr
            },
            activeLink(arr) {
                let childns = Topo.scene.children.filter(x => x.params).filter(x => x.params.type == "link")
                arr.forEach(y => {
                    let acline = childns.filter(x => {
                        let params = x.params
                        return params.target == y.target && params.source == y.source
                    })[0]
                    Topo.activeShowLink(acline)
                })
            },
            activeShowLink(link) {
                let nums = 0
                let time = setInterval(x => {
                    nums += 1
                    link.geometry.colorsNeedUpdate = true
                    if (nums % 2 == 0) {
                        link.geometry.colors[0] = new THREE.Color(0x42aaff)
                        link.geometry.colors[1] = new THREE.Color(0x42aaff)
                    } else {
                        link.geometry.colors[0] = new THREE.Color(0xff0000)
                        link.geometry.colors[1] = new THREE.Color(0xff0000)
                    }
                    if (nums == 20) {
                        clearInterval(time)
                    }
                }, 300)
            },
            getNodeTop(id, arr) {
                //找到节点上级一直到路由器 
                let srcNode = Topo.nexus.nodes.filter(x => x.type == 4)[0]
                // let srcNode = 126
                let links = Topo.nexus.links;
                let link = links.filter(x => x.target == id)[0]

                if (!link) {
                    return
                }
                if (link.source == srcNode) {
                    arr.push(link)
                    return "终结"
                } else {
                    arr.push(link)
                    Topo.getNodeTop(link.source, arr)
                }
            },
            getNode(id) {
                //根据ID返回
                let nodes = Topo.getNodes();
                return nodes.filter(node => node.params.id == id)[0]
            },
            refresh(data) {
                //开始重新加载
                Topo.scene.children = Topo.scene.children.filter((node, index) => index < 4)
                setTimeout(() => {
                    let cloneNexus = {
                        ...data
                    }
                    cloneNexus.nodes.forEach(node => {
                        node.x = Math.random() * 400 - 200
                        node.y = Math.random() * 200
                        node.z = Math.random() * 400 - 200
                    })
                    Topo.nexus = cloneNexus;
                    Topo.initData()
                    setTimeout(() => {
                        Topo.attackEvent({
                            src: "10.101.20.112",
                            dst: "10.101.12.229"
                        })
                    }, 1000)
                }, 200)
            },
            addIdLink(x, y) {
                //根据ID添加
                console.log(Topo.getNode(x))
                let xnode = Topo.getNode(x).position;
                let ynode = Topo.getNode(y).position;
                Topo.addLink({
                    x: {
                        ...xnode,
                        id: x
                    },
                    y: {
                        ...ynode,
                        id: y
                    }
                })
            },
            postMessage(obj) {
                //传递对象过去
                //接受传递过来的消息 
                window.addEventListener('message', function (event) {
                    //接受父元素信息
                    let datas = event.data;
                    let { type, data } = datas;
                    /**
                     * @param type 1获取到当前 2添加一个node
                     * 
                    */
                    if (type == 2) {
                        //从主页面接受过来的参数 
                        Topo.initObj({
                            mtl: "./obj/" + data.typeName + ".mtl",
                            obj: "./obj/" + data.typeName + ".obj",
                            ...data
                        })
                        
                        let parentP
                        if (Topo.getNode(data.parent)) {
                            parentP = Topo.getNode(data.parent).position;
                        }
                        if (data.type == 6) {
                            //防火墙 
                            let lnks = Topo.getLinks()
                            lnks.forEach((l, i) => {
                                if (l.params.source == data.parent) {

                                }
                                if (l.params.source == data.parent && l.params.target == data.next) {
                                    // Nexus.links.splice(i,1) 
                                    Topo.scene.remove(l)
                                    return
                                }
                            })
                            //然后添加两根连线
                            let link1 = {
                                source: data.parent,
                                target: data.id
                            }
                            let link2 = {
                                source: data.id,
                                target: data.next
                            }
                            setTimeout(x => {
                                Topo.addIdLink(data.id, data.parent)
                                Topo.addIdLink(data.next, data.id)
                            }, 200)
                        }
                        else {
                            if (parentP&&data.type!==4) {
                                Topo.addLink({
                                    x: {
                                        x: data.x,
                                        y: data.y,
                                        z: data.z,
                                        id: data.id
                                    },
                                    y: {
                                        ...parentP,
                                        id: data.parent
                                    }
                                })
                            }
                        }

                    } else
                        if (type == 1) {
                            Topo.currNode = data;
                            Topo.currSelectnode = Topo.scene.children.filter(x => {
                                if (!x.params) {
                                    return false
                                } else {
                                    if (x.params.type == "node") {
                                        return x.params.id == data.id
                                    }
                                }
                            })[0]
                            if (Topo.currSelectnode !== undefined) {
                                Topo.inputX.value = Topo.currSelectnode.position.x
                                Topo.inputY.value = Topo.currSelectnode.position.z
                                Topo.nodeChangeLink(Topo.currSelectnode)
                                Topo.selectBoxBackground({
                                    ...Topo.currSelectnode.position
                                })
                            }
                        } else if (type == 3) {
                            //找到当前所有的下级 以及和下级有关的连线
                            let arr = []
                            let nodes = Topo.getNodes();
                            let links = Topo.getLinks();
                            function getNodeid(id) {
                                arr.push(id)
                                let link1 = links.filter(l => l.params.source == id)
                                let line = link1.map(l => l.params.target)
                                link1.forEach(x => {
                                    Topo.scene.remove(x)
                                })
                                if (line.length != 0) {
                                    line.forEach(x => {
                                        getNodeid(x)
                                    })
                                }
                            }
                            getNodeid(data.id)
                            links = Topo.getLinks();
                            //删除连接到的
                            links.forEach(x => {
                                if (x.params.target == data.id) {
                                    Topo.scene.remove(x)
                                }
                            })
                            nodes.forEach(x => {
                                if (x.params) {
                                    if (arr.indexOf(x.params.id) != -1) {
                                        Topo.scene.remove(x)
                                        Topo.deleteFont(x.params.id)
                                    }
                                }
                            })
                            Topo.deleteselectBox()
                        }
                    if (type) {
                        setTimeout(x => {
                            Topo.biuParent(Topo.save())
                        }, 210)
                    }
                }, false);
            },
            //删除选中狂
            deleteselectBox() {
                Topo.scene.children.forEach(x => {
                    if (x.params) {
                        if (x.params.type == "selectBox") {
                            Topo.scene.remove(x)
                        }
                    }
                })
            },
            deleteFont(id) {
                //删除文字
                console.log(id)
                let nodes = Topo.scene.children.filter(x => {
                    if (x.params) {
                        return x.params.type == "font" && x.params.id == id
                    }
                })
                Topo.scene.remove(...nodes)
            },
            biuParent(msg) {
                //给父元素发送信息
                window.parent.postMessage(msg, '*');
            },
            getLinks() {
                //获取所有的link
                return Topo.scene.children.filter(node => {
                    if (!node.params) {
                        return
                    } else {
                        return node.params.type === "link"
                    }
                })
            },
            getNodes() {
                //获取所有的link
                return Topo.scene.children.filter(node => {
                    if (!node.params) {
                        return
                    } else {
                        return node.params.type === "node"
                    }
                })
            },
            nodeChangeLink(node) {
                //根据节点ID  更新相关的连线
                /* node.position.x =  Math.random()*100;
                node.position.y = Math.random()*100;
                node.position.z =  Math.random()*100; */
                //找到跟当前所有有关的连线 
                let source = Topo.getLinks().filter(l => l.params.source == node.params.id)
                let target = Topo.getLinks().filter(l => l.params.target == node.params.id)

                source.forEach(x => {
                    x.geometry.verticesNeedUpdate = true;
                    x.geometry.vertices[1].x = node.position.x;
                    x.geometry.vertices[1].z = node.position.z;
                    x.geometry.vertices[1].y = node.position.y;
                })

                target.forEach(x => {
                    x.geometry.verticesNeedUpdate = true;
                    x.geometry.vertices[0].x = node.position.x;
                    x.geometry.vertices[0].z = node.position.z;
                    x.geometry.vertices[0].y = node.position.y;
                })

            },
            save() {
                //保存所有的节点
                let links = Topo.getLinks().map(link => {
                    return {
                        source: link.params.source,
                        target: link.params.target
                    }
                });
                let nodes = Topo.getNodes().map(node => {
                    return {
                        id: node.params.id,
                        ip: node.params.ip || '',
                        dep: node.params.dep || '',
                        type: node.params.type1 || '',
                        typeName: node.params.typeName || '',
                        ...node.position
                    }
                });
                return {
                    nodes: nodes,
                    links: links
                }
            },
            selectBoxBackground(params) {
                //作为选中盒子的背景
                if (!Topo.Selectnode) {
                    //如果没有盒子 
                    var geometry = new THREE.BoxGeometry(12, 12, 12);
                    var material = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        wireframe: true,
                        wireframeLinecap: "butt",
                        skinning: true,
                    });
                    var cube = new THREE.Mesh(geometry, material);
                    cube.params = {}
                    cube.params.type = "selectBox"
                    cube.position.x = params.x;
                    cube.position.y = params.y;
                    cube.position.z = params.z;
                    Topo.Selectnode = cube
                    Topo.scene.add(cube)
                } else {
                    Topo.Selectnode.position.x = params.x;
                    Topo.Selectnode.position.y = params.y;
                    Topo.Selectnode.position.z = params.z;
                }
            },
            getParentNode(id){
                //根据ID找到
                let nodes = Topo.getNodes()
                let links = Topo.getLinks();
                let parentId = links.filter(l=>l.params.target==id).map(x=>x.params.source) 
                return nodes.filter(n=>parentId.includes(n.params.id))
            },
            getChildrenNode(id){ 
                //根据ID找到
                let nodes = Topo.getNodes()
                let links = Topo.getLinks(); 
                let parentId = links.filter(l=>l.params.source==id).map(x=>x.params.target) 
                return nodes.filter(n=>parentId.includes(n.params.id))
            },
            moveSwitch(node) { 
                //如果当前是交换机
                if(node.params.type1!==3){
                    return
                }
                let id = node.params.id;
                //移动头部有字体
                let nodes = Topo.scene.children.filter(x => {
                    if (x.params) {
                        return x.params.type == "font" && x.params.id == id
                    }
                })
                nodes.forEach(n => {
                    n.position.x = node.position.x
                    n.position.y = node.position.y + 15
                    n.position.z = node.position.z
                })

                //判断下一级是否交换机或者入侵检测
                let parent = Topo.getParentNode(node.params.id)
                let children = Topo.getChildrenNode(node.params.id)
                parent.filter(n=>n.params.type1==6).forEach(n=>{
                    let p = Topo.getParentNode(n.params.id)[0] 
                    n.position.x = node.position.x + (p.position.x - node.position.x) / 3
                    n.position.y = node.position.y + (p.position.y - node.position.y) / 3
                    n.position.z = node.position.z + (p.position.z - node.position.z) / 3
                    Topo.nodeChangeLink(n)
                })
                children.filter(n=>n.params.type1==5).forEach(n=>{
                    let p = Topo.getChildrenNode(n.params.id)[0] 
                    n.position.x = node.position.x  
                    n.position.y = node.position.y  
                    n.position.z = node.position.z + 50
                    Topo.nodeChangeLink(n)
                })

            },
            load() {
                Topo.nexus = nexus;
                Topo.initCamea()
                Topo.onWindowResize()
                Topo.initFooter()
                Topo.initLight()
                Topo.initData()
                Topo.initControls()
                Topo.initStats()
                Topo.renders()
                Topo.postMessage()
                window.addEventListener("resize", Topo.onWindowResize)
                Topo.inputX = document.getElementById("positionX")
                Topo.inputY = document.getElementById("positionY")
                Topo.inputX.oninput = function (e) {
                    let num = e.target.value;
                    if (Topo.currSelectnode) {
                        Topo.currSelectnode.position.x = parseInt(num)
                        Topo.nodeChangeLink(Topo.currSelectnode)
                        Topo.moveSwitch(Topo.currSelectnode)
                        Topo.selectBoxBackground({
                            ...Topo.currSelectnode.position
                        })
                    }
                }
                Topo.inputY.oninput = function (e) {
                    let num = e.target.value;
                    if (Topo.currSelectnode) {
                        Topo.currSelectnode.position.z = parseInt(num)
                        Topo.nodeChangeLink(Topo.currSelectnode)
                        Topo.moveSwitch(Topo.currSelectnode)
                        Topo.selectBoxBackground({
                            ...Topo.currSelectnode.position
                        })
                    }
                }
                setTimeout(() => {
                    Topo.attackEvent({
                        src: "10.101.20.112",
                        dst: "10.101.12.229"
                    })
                }, 2000)
                let quitBtn = document.getElementById("quit");
                let topBtn = document.getElementById("moveTop");
                let bottomBtn = document.getElementById("moveBottom");
                function quitSelect() {
                    Topo.Selectnode.material.dispose();
                    Topo.Selectnode.geometry.dispose();
                    Topo.scene.remove(Topo.Selectnode)
                    Topo.currNode = null;
                    Topo.currSelectnode = null;
                    Topo.Selectnode = null;
                    Topo.inputX.value = ""
                    Topo.inputY.value = ""
                }
                quitBtn.onclick = function () {
                    if (!Topo.Selectnode) {
                        return
                    }
                    quitSelect()
                }
                function move(state) {
                    if (Topo.Selectnode) {
                        Topo.deleteselectBox()
                    }
                    let type = Topo.currSelectnode.params.type1;
                    let nodes = Topo.getNodes().filter(n => n.params.type1 == 1 || n.params.type1 == 2)
                    if (type == 1 || type == 2) {
                        nodes.forEach(x => {
                            if (state) {
                                //抬高
                                x.position.y += 1
                            } else {
                                //降低
                                x.position.y -= 1
                            }
                            Topo.nodeChangeLink(x)
                            Topo.selectBoxBackground({
                                ...x.position
                            })
                        })
                    } else if (type == 3) {
                        //找到和当前同一高度的交换机
                    }
                }
                topBtn.onclick = function () {
                    move(true)
                }
                bottomBtn.onclick = function () {
                    move(false)
                }
            },
        }
        window.onload = function () {
            Topo.load()
        }
    </script>
</head>

<body>
    <canvas id="mainCanvas" width="1600px" height="800px" style="position: absolute;left:0;top: 0;"></canvas>
    <div class="inputPositiobn">
        <ul>
            <li>
                <input type="number" id="positionX">
            </li>
            <li>
                <input type="number" id="positionY">
            </li>
            <li></li>
            <li>
                <button id="moveTop">整体抬高</button>
            </li>
            <li>
                <button id="moveBottom">整体降低</button>
            </li>
            <li>
                <button id="quit">quit</button>
            </li>
        </ul>
    </div>
    <div id="stats" style="position:absolute;left:0;top:0;"></div>
</body>

</html>